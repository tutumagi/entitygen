package main

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"

	// 代码生成库
	. "github.com/dave/jennifer/jen"
)

func main() {
	// 1. 获取参数
	if len(os.Args) != 2 {
		failErr(fmt.Errorf("expected exactly on argument"))
	}

	// 2. 拿到参数
	sourceArg := os.Args[1] // 包名.类型名
	// 如果要生成的是 包名/路径.类型格式的，则加载指定类型
	if len(strings.Split(sourceArg, ".")) >= 2 {
		sourceTypePackage, sourceTypeName := splitSourceType(sourceArg)

		// 3. 加载包
		pkg := loadPackage(sourceTypePackage)

		// 4. 搜索这个包有没有这个类型
		obj := pkg.Types.Scope().Lookup(sourceTypeName)
		if obj == nil {
			failErr(fmt.Errorf("%s not found in declared types of %s", sourceTypeName, pkg))
		}

		// 5. 判断 sourceTypeName 是否是个类型名字
		if _, ok := obj.(*types.TypeName); !ok {
			failErr(fmt.Errorf("%s is not a named type", obj))
		}

		// 6. 判断 类型名字 的含义是否是个 struct
		structType, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			failErr(fmt.Errorf("type %v is not a struct", obj))
		}

		err := generate(sourceTypeName, structType)
		if err != nil {
			failErr(err)
		}
	} else {
		pkg := loadPackage(sourceArg)

		type ssInfo struct {
			name    string
			structt *types.Struct
		}
		allStrucs := make([]ssInfo, 0, len(pkg.TypesInfo.Types))
		for _, tt := range pkg.TypesInfo.Defs {
			// 这里为 nil 情况就是类似 go 源文件第一行写着 `package domain`，则 ast 是有的，不过类型定义为 nil
			if tt != nil {
				switch v := tt.Type().(type) {
				case *types.Basic:
					fmt.Printf("collect types name:%s type:%s. skip it\n", tt.Name(), tt.Type())
				case *types.Map:
					fmt.Printf("collect types name:%s type:%s. \n", tt.Name(), tt.Type())
				case *types.Struct:
					fmt.Printf("collect types name:%s type:%s. \n", tt.Name(), tt.Type())
					allStrucs = append(allStrucs, ssInfo{
						name:    tt.Name(),
						structt: v,
					})
				case *types.Named: // 某个字段是自定义类型 会跑到这里
					// fmt.Printf("collect types is named: %s. \n", tt.Type.String())
					fmt.Printf("collect types(named) name:%s type:%s. \n", tt.Name(), tt.Type())
					allStrucs = append(allStrucs, ssInfo{
						name:    tt.Name(),
						structt: tt.Type().Underlying().(*types.Struct),
					})
				}
			}
		}
		// for _, tt := range pkg.TypesInfo.Types {
		// 	// fmt.Printf("collect types is buildin:%v %s\n", tt.IsBuiltin(), tt.Type.String())

		// 	switch v := tt.Type.(type) {
		// 	case *types.Basic:
		// 		fmt.Printf("collect types is %s. skip it.\n", v.Name())
		// 	case *types.Map:
		// 		fmt.Printf("collect types is %s.\n", tt.Type.String())
		// 	case *types.Struct:
		// 		fmt.Printf("collect types is %s value:%v.\n", v.String(), tt.Value)
		// 		allStrucs = append(allStrucs, v)
		// 	case *types.Named: // 某个字段是自定义类型 会跑到这里
		// 		// fmt.Printf("collect types is named: %s. \n", tt.Type.String())
		// 		fmt.Printf("collect types is named: %s. \n", v.Obj().Name())

		// 	}
		// }
		for _, info := range allStrucs {
			err := generate(info.name, info.structt)
			if err != nil {
				failErr(err)
			}
		}
		return
	}

}

func genStructName(srcName string) string {
	return srcName + "Def"
}

func generate(sourceTypeName string, structType *types.Struct) error {
	fmt.Printf("begin generate type:%s\n", sourceTypeName)

	// 1. 对 struct 做一些准备工作
	// 读取 types.Struct 所有字段信息，计算出我们要的信息，并做合法性判断
	fields := getStructFields(structType)

	// 生成的结构体名字 XXXDef
	structName := genStructName(sourceTypeName)
	// 生成的对应的数据结构描述的名字 XXXAttrDef
	attrDefName := strings.ToLower(sourceTypeName) + "AttrDef"

	// 一些预设的类型或者关键字
	// *attr.StrMap
	attrStrMap := func() *Statement { return Id("*").Qual("entitygen/attr", "StrMap") }
	// attr.Field
	attrField := func() *Statement { return Qual("entitygen/attr", "Field") }
	// 将 name 变量转为 *attr.StrMap类型: (*attr.StrMap)(name)
	convertAttrStrMap := func(name string) *Statement { return Parens(attrStrMap()).Parens(Id(name)) }
	// a *XXXDef
	thisFn := func() *Statement { return Id("a").Op("*").Id(structName) }
	// 将 "a" 转为 *attr.StrMap 类型：(*attr.StrMap)(a)
	convertThisFn := func() *Statement { return convertAttrStrMap("a") }

	// 2. 获取环境变量，初始化要生成的定义的文件`句柄`
	goPackage := os.Getenv("GOPACKAGE")

	f := NewFile(goPackage)

	// 3. 开始写定义
	// 3.1 第一行写注释
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	// 3.2 写 attrDef
	writeAttrDef(f, attrDefName, fields)

	// 3.3 写定义  type XXXDef attr.StrMap
	f.Type().Id(structName).Qual(
		"entitygen/attr",
		"StrMap",
	)

	// 3.4 写构造函数
	writeCtor(f, structName, sourceTypeName, fields)

	// 3.5 写所有字段的 getter/setter
	err := writeGetterSetter(f, fields, thisFn, convertThisFn)
	if err != nil {
		failErr(err)
	}

	// 3.6 写自定义方法
	writeCustomMethod(f, structName, attrField, thisFn, convertThisFn, convertAttrStrMap)

	// 3.7 写 marshal & unmarshal
	writeEncodeDecode(f, thisFn, convertThisFn, attrDefName)

	// 3.8 dump 到 文件
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(sourceTypeName) + "_gen.go"

	return f.Save(targetFilename)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection:%v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	return pkgs[0]
}

// 解析字符串，拿到哪个包里面的，哪个类型字符串
func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.Mytype"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
