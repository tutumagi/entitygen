package main

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"golang.org/x/tools/go/packages"

	// 代码生成库
	. "github.com/dave/jennifer/jen"
)

func main() {
	// 1. 获取参数
	if len(os.Args) != 2 {
		failErr(fmt.Errorf("expected exactly on argument"))
	}

	// 2. 拿到参数
	sourceType := os.Args[1] // 包名.类型名
	sourceTypePackage, sourceTypeName := splitSourceType(sourceType)

	// 3. 加载包
	pkg := loadPackage(sourceTypePackage)

	// 4. 搜索这个包有没有这个类型
	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s", sourceTypeName, pkg))
	}

	// 5. 判断 sourceTypeName 是否是个类型名字
	if _, ok := obj.(*types.TypeName); !ok {
		failErr(fmt.Errorf("%s is not a named type", obj))
	}

	// 6. 判断 类型名字 的含义是否是个 struct
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		failErr(fmt.Errorf("type %v is not a struct", obj))
	}

	// 7. 遍历所有的 struct 的名字
	// for i := 0; i < structType.NumFields(); i++ {
	// 	field := structType.Field(i)
	// 	tagValue := structType.Tag(i)
	// 	fmt.Println(field.Name(), tagValue, field.Type())
	// }

	err := generate(sourceTypeName, structType)
	if err != nil {
		failErr(err)
	}
}

var structJsonPattern = regexp.MustCompile(`json:"([^"]+)"`)
var structBsonPattern = regexp.MustCompile(`bson:"([^"]+)"`)

const (
	ParentKeyName  = "parentKey"
	AttrsFieldName = "attrs"
)

func generate(sourceTypeName string, structType *types.Struct) error {
	goPackage := os.Getenv("GOPACKAGE")

	f := NewFile(goPackage)

	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	fmt.Printf("begin generate type:%s\n", sourceTypeName)

	attrStrMap := func() *Statement { return Id("*").Qual("entitygen/attr", "StrMap") }
	attrField := func() *Statement { return Qual("entitygen/attr", "Field") }
	attrDef := func() *Statement { return Id("*").Qual("entitygen/attr", "Def") }

	// 写 attrDef
	attrDefName := strings.ToLower(sourceTypeName) + "AttrDef"
	// var xxxAttrDef *attr.Def
	f.Var().Id(attrDefName).Add(attrDef())
	f.Func().Id("init").Params().
		BlockFunc(
			func(g *Group) {
				g.Id(attrDefName).Op("=").Op("&").Qual("entitygen/attr", "Def").Block()

				for i := 0; i < structType.NumFields(); i++ {
					g.Id(attrDefName).CallFunc(func(g *Group) {

					})
				}

			},
		)

	// 1. 写定义  type XXXDef attr.StrMap
	structName := sourceTypeName + "Def"
	f.Type().Id(structName).Qual(
		"entitygen/attr",
		"StrMap",
	)

	// 2. 写字段的 getter/setter

	thisFn := func() *Statement { return Id("a").Op("*").Id(structName) }
	convertThisFn := func() *Statement { return Parens(attrStrMap()).Parens(Id("a")) }

	for i := 0; i < structType.NumFields(); i++ {

		field := structType.Field(i)
		// tagValue := structType.Tag(i)

		fieldName := field.Name()
		// TODO  从结构化数据中的 tag 读取出来
		fieldKeyName := strings.ToLower(fieldName)

		switch v := field.Type().(type) {
		case *types.Basic:
			// 写 getter
			// attr.StrMap 的 get 方法
			// 如果是基础类型，则直接大写第一个字母的方法进行 getter 比如 int32 就是 .Int32("xxx")
			// 如果是 string 类型，则使用 Str 方法，比如 .Str("yyy")
			attrGetFuncName := strings.Title(v.Name())
			switch v.Kind() {
			case types.String, types.UntypedString:
				attrGetFuncName = "Str"
			}

			// func (a *XXXDef) GetField() FieldType
			f.Func().Params(thisFn()).Id(fmt.Sprintf("Get%s", fieldName)).Params().Id(v.Name()).
				Block(
					Return(
						convertThisFn().Dot(attrGetFuncName).Params(Lit(fieldKeyName)),
					),
				)

			//  写 setter
			f.Func().Params(thisFn()).Id(fmt.Sprintf("Set%s", fieldName)).Params(Id(fieldKeyName).Id(v.Name())).
				Block(
					convertThisFn().Dot("Set").Params(Lit(fieldKeyName), Id(fieldKeyName)),
				)

			// 换行符
			f.Line()
		case *types.Map:
			switch mapK := v.Key().(type) {
			case *types.Basic:
				if mapK.Kind() == types.Int32 || mapK.Kind() == types.String {

				} else {
					return fmt.Errorf("不支持的map key，目前 map key 只支持 int32 和 string. %T", mapK)
				}
			default:
				return fmt.Errorf("不支持的map key，目前 map key 只支持 zint32 和 string. %T", mapK)
			}
			// getter

		case *types.Named:

			// typName := v.Obj()
			// // Qual automatically imports packages
			// code.Op("*").Qual(
			// 	typName.Pkg().Path(),
			// 	typName.Name(),
			// )
		default:
			return fmt.Errorf("struct field type not handled: %T", v)
		}
	}

	// 3. 写 changekey 相关的
	f.Func().Params(thisFn()).Id("HasChange").Params().Bool().
		Block(
			Return(convertThisFn().Dot("HasChange").Call()),
		)

	f.Func().Params(thisFn()).Id("ChangeKey").Params().Map(String()).Struct().
		Block(
			Return(convertThisFn().Dot("ChangeKey").Call()),
		)

	f.Func().Params(thisFn()).Id("ClearChangeKey").Params().
		Block(
			convertThisFn().Dot("ClearChangeKey").Call(),
		)

	// 4. 写 setParent
	f.Func().Params(thisFn()).Id("setParent").Params(Id("k").String(), Id("parent").Add(attrField())).
		Block(
			convertThisFn().Dot("SetParent").Call(Id("k"), Id("parent")),
		)

	// 5. ForEach
	f.Func().Params(thisFn()).Id("ForEach").Params(Id("fn").Func().Params(Id("s").String(), Id("v").Interface()).Bool()).
		Block(
			convertThisFn().Dot("ForEach").Call(Id("fn")),
		)

	// 6. 写 json marshal & unmarshal
	// marshal
	f.Func().Params(thisFn()).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).
		Block(
			Return(Qual("encoding/json", "Marshal").Call(convertThisFn().Dot("ToMap").Params())),
		)
	// // unmarshal
	// f.Func().Params(thisFn()).Id("UnmarshalJSON").Params().Params(Index().Byte()).Error().
	// 	Block(
	// 		Return(Qual("encoding/json", "UnmarshalJson").Call(convertThisFn().Dot("ToMap").Params())),
	// 	)

	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(sourceTypeName) + "_gen.go"

	return f.Save(targetFilename)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection:%v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.Mytype"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
