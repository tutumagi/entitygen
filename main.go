package main

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"golang.org/x/tools/go/packages"

	// 代码生成库
	. "github.com/dave/jennifer/jen"
)

func main() {
	// 1. 获取参数
	if len(os.Args) != 2 {
		failErr(fmt.Errorf("expected exactly on argument"))
	}

	// 2. 拿到参数
	sourceType := os.Args[1] // 包名.类型名
	sourceTypePackage, sourceTypeName := splitSourceType(sourceType)

	// 3. 加载包
	pkg := loadPackage(sourceTypePackage)

	// 4. 搜索这个包有没有这个类型
	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s", sourceTypeName, pkg))
	}

	// 5. 判断 sourceTypeName 是否是个类型名字
	if _, ok := obj.(*types.TypeName); !ok {
		failErr(fmt.Errorf("%s is not a named type", obj))
	}

	// 6. 判断 类型名字 的含义是否是个 struct
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		failErr(fmt.Errorf("type %v is not a struct", obj))
	}

	// 7. 遍历所有的 struct 的名字
	// for i := 0; i < structType.NumFields(); i++ {
	// 	field := structType.Field(i)
	// 	tagValue := structType.Tag(i)
	// 	fmt.Println(field.Name(), tagValue, field.Type())
	// }

	err := generate(sourceTypeName, structType)
	if err != nil {
		failErr(err)
	}
}

var structJsonPattern = regexp.MustCompile(`json:"([^"]+)"`)
var structBsonPattern = regexp.MustCompile(`bson:"([^"]+)"`)

const (
	ParentKeyName  = "parentKey"
	AttrsFieldName = "attrs"
)

func generate(sourceTypeName string, structType *types.Struct) error {
	goPackage := os.Getenv("GOPACKAGE")

	f := NewFile(goPackage)

	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	fmt.Printf("begin generate type:%s\n", sourceTypeName)

	fields := getStructFields(structType)

	attrStrMap := func() *Statement { return Id("*").Qual("entitygen/attr", "StrMap") }
	attrField := func() *Statement { return Qual("entitygen/attr", "Field") }
	attrDef := func() *Statement { return Id("*").Qual("entitygen/attr", "Def") }

	// 写 attrDef
	attrDefName := strings.ToLower(sourceTypeName) + "AttrDef"
	// var xxxAttrDef *attr.Def
	f.Var().Id(attrDefName).Add(attrDef())
	f.Func().Id("init").Params().
		BlockFunc(
			func(g *Group) {
				g.Id(attrDefName).Op("=").Op("&").Qual("entitygen/attr", "Def").Block()
				g.Line()

				for i := 0; i < len(fields); i++ {
					field := fields[i]

					switch v := field.typ.(type) {
					case *types.Basic:
						g.Id(attrDefName).Dot("DefAttr").CallFunc(func(ig *Group) {
							ig.Lit(field.key)
							ig.Qual("entitygen/attr", strings.Title(v.Name()))

							if field.cell {
								ig.Qual("entitygen/attr", "AfCell")
							} else {
								ig.Qual("entitygen/attr", "AfBase")
							}

							if field.storeDB {
								ig.True()
							} else {
								ig.False()
							}
						})
					}

				}

			},
		)

	// 1. 写定义  type XXXDef attr.StrMap
	structName := sourceTypeName + "Def"
	f.Type().Id(structName).Qual(
		"entitygen/attr",
		"StrMap",
	)

	// 2. 写字段的 getter/setter

	thisFn := func() *Statement { return Id("a").Op("*").Id(structName) }
	convertThisFn := func() *Statement { return Parens(attrStrMap()).Parens(Id("a")) }

	for i := 0; i < len(fields); i++ {

		field := fields[i]

		switch v := field.typ.(type) {
		case *types.Basic:
			// 写 getter
			// attr.StrMap 的 get 方法
			// 如果是基础类型，则直接大写第一个字母的方法进行 getter 比如 int32 就是 .Int32("xxx")
			// 如果是 string 类型，则使用 Str 方法，比如 .Str("yyy")
			attrGetFuncName := strings.Title(v.Name())
			switch v.Kind() {
			case types.String, types.UntypedString:
				attrGetFuncName = "Str"
			}

			// func (a *XXXDef) GetField() FieldType
			f.Func().Params(thisFn()).Id(fmt.Sprintf("Get%s", field.name)).Params().Id(v.Name()).
				Block(
					Return(
						convertThisFn().Dot(attrGetFuncName).Params(Lit(field.key)),
					),
				)

			//  写 setter
			f.Func().Params(thisFn()).Id(fmt.Sprintf("Set%s", field.name)).Params(Id(field.key).Id(v.Name())).
				Block(
					convertThisFn().Dot("Set").Params(Lit(field.key), Id(field.key)),
				)

			// 换行符
			f.Line()
		case *types.Map:
			switch mapK := v.Key().(type) {
			case *types.Basic:
				if mapK.Kind() == types.Int32 || mapK.Kind() == types.String {

				} else {
					return fmt.Errorf("不支持的map key，目前 map key 只支持 int32 和 string. %T", mapK)
				}
			default:
				return fmt.Errorf("不支持的map key，目前 map key 只支持 zint32 和 string. %T", mapK)
			}
			// getter

		case *types.Named:

			// typName := v.Obj()
			// // Qual automatically imports packages
			// code.Op("*").Qual(
			// 	typName.Pkg().Path(),
			// 	typName.Name(),
			// )
		default:
			return fmt.Errorf("struct field type not handled: %T", v)
		}
	}

	// 3. 写 changekey 相关的
	f.Func().Params(thisFn()).Id("HasChange").Params().Bool().
		Block(
			Return(convertThisFn().Dot("HasChange").Call()),
		)

	f.Func().Params(thisFn()).Id("ChangeKey").Params().Map(String()).Struct().
		Block(
			Return(convertThisFn().Dot("ChangeKey").Call()),
		)

	f.Func().Params(thisFn()).Id("ClearChangeKey").Params().
		Block(
			convertThisFn().Dot("ClearChangeKey").Call(),
		)

	// 4. 写 setParent
	f.Func().Params(thisFn()).Id("setParent").Params(Id("k").String(), Id("parent").Add(attrField())).
		Block(
			convertThisFn().Dot("SetParent").Call(Id("k"), Id("parent")),
		)

	// 5. ForEach
	f.Func().Params(thisFn()).Id("ForEach").Params(Id("fn").Func().Params(Id("s").String(), Id("v").Interface()).Bool()).
		Block(
			convertThisFn().Dot("ForEach").Call(Id("fn")),
		)

	// 6. 写 json marshal & unmarshal
	// marshal
	f.Func().Params(thisFn()).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).
		Block(
			Return(Qual("encoding/json", "Marshal").Call(convertThisFn().Dot("ToMap").Params())),
		)
	// // unmarshal
	// f.Func().Params(thisFn()).Id("UnmarshalJSON").Params().Params(Index().Byte()).Error().
	// 	Block(
	// 		Return(Qual("encoding/json", "UnmarshalJson").Call(convertThisFn().Dot("ToMap").Params())),
	// 	)

	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(sourceTypeName) + "_gen.go"

	return f.Save(targetFilename)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection:%v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.Mytype"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

type structField struct {
	name    string
	key     string
	typ     types.Type
	storeDB bool
	base    bool
	cell    bool
	client  bool
}

func getStructFields(structType *types.Struct) []*structField {
	result := make([]*structField, 0, structType.NumFields())
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		name := field.Name()
		typ := field.Type()
		storeDB := false
		flagBase := true // 目前的实现里面属性肯定会存储在 base 里面
		flagCell := false
		client := false

		tagValue := reflect.StructTag(structType.Tag(i))
		key, ok := tagValue.Lookup("key")
		if !ok {
			failErr(fmt.Errorf("field:%s 必须有tag:key", name))
		}
		{
			storeDBStr, ok := tagValue.Lookup("storedb")
			if !ok {
				failErr(fmt.Errorf("field:%s 必须有tag:storedb", name))
			}
			if storeDBStr != "true" && storeDBStr != "false" {
				failErr(fmt.Errorf("field:%s storedb(%s) 必须是 true 或者 false", name, storeDBStr))
			}
			if storeDBStr == "true" {
				storeDB = true
			}
		}

		{
			clientStr, ok := tagValue.Lookup("client")
			if !ok {
				failErr(fmt.Errorf("field:%s 必须有tag:client", name))
			}
			if clientStr != "true" && clientStr != "false" {
				failErr(fmt.Errorf("field:%s client(%s) 必须是 true 或者 false", name, clientStr))
			}
			if clientStr == "true" {
				client = true
			}
		}

		{
			flagStr, ok := tagValue.Lookup("flag")
			if !ok {
				failErr(fmt.Errorf("field:%s 必须有tag:flag", name))
			}
			if flagStr != "base" && flagStr != "cell" {
				failErr(fmt.Errorf("field:%s flag(%s) 必须是 base 或者 cell", name, flagStr))
			}
			if flagStr == "cell" {
				flagCell = true
			}
		}

		result = append(result, &structField{
			name:    name,
			key:     key,
			typ:     typ,
			storeDB: storeDB,
			base:    flagBase,
			cell:    flagCell,
			client:  client,
		})
	}
	return result
}
